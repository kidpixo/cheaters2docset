<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="GENERATOR" content="BBEdit 10" />
    <link rel="STYLESHEET" href="../help.css" charset="ISO-8859-1" type="text/css" />
    <title>Searching with Grep</title>
</head>
<body>
    <h2>Searching with Grep</h2>
    <p class="Body">This section describes the Grep option in TextWrangler's Find command, which allows you to find and change text that matches a set of conditions you specify. Combined with the multi-file search and replace features, TextWrangler's grep capabilities can make many editing tasks quicker and easier, whether you are modifying Web pages, extracting data from a file, or just rearranging a phone list.</p>
    <div>
        <hr />
        <h3 id="WhatIsGrep">What Is Grep Searching?</h3>
        <p class="Body">Grep searching (sometimes referred to as &ldquo;pattern&rdquo; or &ldquo;regular expression&rdquo; searching) offers a powerful way to search in and make changes to your text that "plain text" searches simply cannot. For example, suppose you have a list of people's names that you want to alphabetize. If the names appear last name first, you can easily put these names in a TextWrangler window and use the Sort tool. But if the list is arranged first name first, a simple grep pattern can be used to put the names in the proper order for sorting.</p>
        <p class="Body">A grep pattern, also known as a regular expression, describes the text that you are looking for. For instance, a pattern can describe words that begin with C and end in l. A pattern like this would match "Call", "Cornwall", and "Criminal" as well as hundreds of other words.</p>
        <p class="Body">In fact, you have probably already used pattern searching without realizing it. The Find &amp; Replace dialog's "Match Case" and "Entire Word" options turn on special searching patterns. Suppose that you are looking for "corn". With the "Match Case" option turned off, you are actually looking for a pattern that says: look for a C or c, O or o, R or r, and N or n. With the "Entire Word" option on, you are looking for the string "corn" only if it is surrounded by white space or punctuation characters; special search characters, called metacharacters, are added to the search string you specified to indicate this.</p>
        <p class="Body">What makes pattern searching counterintuitive at first is how you describe the pattern. Consider the first example above, where we want to search for text that begins with the letter "C" and ends with the letter "l" with any number of letters in between. What exactly do you put between them that means "any number of letters"? That is what this chapter is all about.</p>
        <div>
            <h6 class="Note-Head">Note</h6>
            <p class="Note-Text">Grep is the name of a frequently used Unix command that searches using regular expressions, the same type of search pattern used by TextWrangler. For this reason, you will often see regular expressions called "grep patterns," as TextWrangler does. They're the same thing.</p>
        </div>
    </div>
    <div>

        <hr />
        <h3 id="SearchPatterns">Writing Search Patterns</h3>
        <p class="Body">This section explains how to create search patterns using TextWrangler's grep syntax. For readers with prior experience, this is essentially like the syntax used for regular expressions in the Perl programming language. (However, you do not need to understand anything about Perl in order to make use of TextWrangler's grep searching.)</p>
        <div>
            <h4>Most Characters Match Themselves</h4>
            <p class="Body">Most characters that you type into the Find &amp; Replace dialog match themselves. For instance, if you are looking for the letter "t", Grep stops and reports a match when it encounters a "t" in the text. This idea is so obvious that it seems not worth mentioning, but the important thing to remember is that these characters are search patterns. Very simple patterns, to be sure, but patterns nonetheless.</p>
        </div>
        <div>
            <h4>Escaping Special Characters</h4>
            <p class="Body">In addition to the simple character matching discussed above, there are various special characters that have different meanings when used in a grep pattern than in a normal search. (The use of these characters is covered in the following sections.)</p>
            <p class="Body">However, sometimes you will need to include an exact, or literal, instance of these characters in your grep pattern. In this case, you must use the backslash character \ before that special character to have it be treated literally; this is known as "escaping" the special character. To search for a backslash character itself, double it \\ so that its first appearance will escape the second.</p>
            <p class="Body">For example, perhaps the most common "special character" in grep is the dot: ".". In grep, a dot character will match any character except a return. But what if you only want to match a literal dot? If you escape the dot: "\.", it will only match another literal dot character in your text.</p>
            <p class="Body">So, most characters match themselves, and even the special characters will match themselves if they are preceded by a backslash. TextWrangler's grep syntax coloring helps make this clear.</p>
            <div>
                <h6 class="Note-Head">Note</h6>
                <p class="Note-Text">When passing grep patterns to TextWrangler via AppleScript, be aware that both the backslash and double-quote characters have special meaning to AppleScript. In order to pass these through correctly, you must escape them in your script. Thus, to pass \r for a carriage return to TextWrangler, you must write \\r in your AppleScript string.</p>
            </div>
        </div>
        <div>
            <h4>Wildcards Match Types of Characters</h4>
            <p class="Body">These special characters, or metacharacters, are used to match certain types of other characters:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Wildcard</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches...</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">.</p>
                    </td>
                    <td>
                        <p class="CellBody">any character except a line break (that is, a carriage return)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">^</p>
                    </td>
                    <td>
                        <p class="CellBody">beginning of a line (unless used in a character class)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">$</p>
                    </td>
                    <td>
                        <p class="CellBody">end of line (unless used in a character class)</p>
                    </td>
                </tr>
            </table>
            <p class="Body">Being able to specifically match text starting at the beginning or end of a line is an especially handy feature of grep. For example, if you wanted to find every instance of a message sent by Patrick, from a log file which contains various other information like so:</p>
            <p class="Code-Indented-No-Space">From: Rich, server: barebones.com</p>
            <p class="Code-Indented-No-Space">To: TextWrangler-Talk, server: lists.barebones.com</p>
            <p class="Code-Indented">From: Patrick, server: example.barebones.com</p>
            <p class="Body">you could search for the pattern:</p>
            <p class="Code-Indented">^From: Patrick</p>
            <p class="Body">and you will find every occurrence of these lines in your file (or set of files if you do a multi-file search instead).</p>
            <p class="Body">It is important to note that ^ and $ do not actually match return characters. They match zero-width positions after and before returns, respectively. So, if you are looking for "foo" at the end of a line, the pattern "<em class="Code">foo$</em> " will match the three characters "f", "o", and "o". If you search for "<em class="Code">foo\r</em> ", you will match the same text, but the match will contain four characters: "f", "o", "o", and a return.</p>
            <div>
                <h6 class="Note-Head">Note</h6>
                <p class="Note-Text">^ and $ do not match the positions after and before soft line breaks.</p>
                <p class="Body">You can combine ^ and $ within a pattern to force a match to constitute an entire line. For example:</p>
                <p class="Code-Indented">^foo$</p>
                <p class="Body">will only match "foo" on a line by itself, with no other characters. Try it against these three lines to see for yourself:</p>
                <p class="Code-Indented">foobar<br />
                foo<br />
                fighting foo</p>
                <p class="Body">The pattern will only match the second line.</p>
            </div>
            <div>
                <h6 class="Note-Head">Note</h6>
                <p class="Note-Text">In versions of TextWrangler prior to 3.0, the # character was a wildcard that matched any digit (0-9); however, this is no longer the case. If you have grep patterns written with an old version of TextWrangler that use # for this purpose, you will need to change these patterns. The easiest way to do this is to use the \d character class, which has the exact same meaning that # used to--it matches any character from 0-9. Character classes are explained in the next section.</p>
            </div>
            <div>
                <h4>Other Positional Assertions</h4>
                <p class="Body">TextWrangler's grep engine supports additional positional assertions, very similar to ^ and $.</p>
                <table>
                    <tr>
                        <th>
                            <p class="CellHeading">Escape</p>
                        </th>
                        <th>
                            <p class="CellHeading">Matches</p>
                        </th>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">\A</p>
                        </td>
                        <td>
                            <p class="CellBody">only at the beginning of the document (as opposed to ^, which matches at the beginning of the document and also at the beginning of each line)</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">\b</p>
                        </td>
                        <td>
                            <p class="CellBody">any word boundary, defined as any position between a \w character and a \W character, in either order</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">\B</p>
                        </td>
                        <td>
                            <p class="CellBody">any position that is not a word boundary</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">\z</p>
                        </td>
                        <td>
                            <p class="CellBody">at the end of the document (as opposed to $, which matches at the end of the document and also at the end of each line)</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">\Z</p>
                        </td>
                        <td>
                            <p class="CellBody">at the end of the document, or before a trailing return at the end of the doc, if there is one</p>
                        </td>
                    </tr>
                </table>
                <p class="Body">Examples (the text matched by the pattern is underlined)</p>
                <p class="Code-Indented"><em class="Number">Search for:</em> \bfoo\b</p>
                <p class="Code-Indented"><em class="Number">Will match:</em> bar <u>foo</u> bar</p>
                <p class="Code-Indented"><em class="Number">Will match:</em> <u>foo</u> bar</p>
                <p class="Code-Indented"><em class="Number">Will not match:</em> foobar</p>
                <p class="Code-Indented">&nbsp;</p>
                <p class="Code-Indented"><em class="Number">Search for:</em> \bJane\b</p>
                <p class="Code-Indented"><em class="Number">Will match:</em> <u>Jane</u>'s</p>
                <p class="Code-Indented"><em class="Number">Will match:</em> Tell <u>Jane</u> about the monkey.</p>
                <p class="Code-Indented">&nbsp;</p>
                <p class="Code-Indented"><em class="Number">Search for:</em> \Afoo</p>
                <p class="Code-Indented"><em class="Number">Will match:</em> <u>foo</u>bar</p>
                <p class="Code-Indented"><em class="Number">Will not match:</em> This is good foo.</p>
            </div>
        </div>
        <div>
            <h4>Character Classes Match Sets or Ranges of Characters</h4>
            <p class="Body">The character class construct lets you specify a set or a range of characters to match, or to ignore. A character class is constructed by placing a pair of square brackets [...] around the group or range of characters you wish to include. To exclude, or ignore, all characters specified by a character class, add a caret character ^ just after the opening bracket [^...]. For example:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Character Class</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[xyz]</p>
                    </td>
                    <td>
                        <p class="CellBody">any one of the characters x, y, z</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[^xyz]</p>
                    </td>
                    <td>
                        <p class="CellBody">any character except x, y, z</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[a-z]</p>
                    </td>
                    <td>
                        <p class="CellBody">any character in the range a to z</p>
                    </td>
                </tr>
            </table>
            <p class="Body">You can use any number of characters or ranges between the brackets. Here are some examples:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Character Class</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[aeiou]</p>
                    </td>
                    <td>
                        <p class="CellBody">any vowel</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[^aeiou]</p>
                    </td>
                    <td>
                        <p class="CellBody">any character that is not a vowel</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[a-zA-Z0-9]</p>
                    </td>
                    <td>
                        <p class="CellBody">any character from a-z, A-Z, or 0-9</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[^aeiou0-9]</p>
                    </td>
                    <td>
                        <p class="CellBody">any character that is neither a vowel nor a digit</p>
                    </td>
                </tr>
            </table>
            <p class="Body">A character class matches when the search encounters any one of the characters in the pattern. However, the contents of a set are only treated as separate characters, not as words. For example, if your search pattern is <em class="Code">[beans]</em> and the text in the window is "lima beans", TextWrangler will report a match at the "a" of the word "lima".</p>
            <p class="Body">To include the character ] in a set or a range, place it immediately after the opening bracket. To use the ^ character, place it anywhere except immediately after the opening bracket. To match a dash character (hyphen) in a range, place it at the beginning of the range; to match it as part of a set, place it at the beginning or end of the set. Or, you can include any of these character at any point in the class by escaping them with a backslash.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Character Class</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[]0-9]</p>
                    </td>
                    <td>
                        <p class="CellBody">any digit or ]</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[aeiou^]</p>
                    </td>
                    <td>
                        <p class="CellBody">a vowel or ^</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[-A-Z]</p>
                    </td>
                    <td>
                        <p class="CellBody">a dash or A - Z</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[--A]</p>
                    </td>
                    <td>
                        <p class="CellBody">any character in the range from - to A</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[aeiou-]</p>
                    </td>
                    <td>
                        <p class="CellBody">any vowel or -</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[aei\-ou]</p>
                    </td>
                    <td>
                        <p class="CellBody">any vowel or -</p>
                    </td>
                </tr>
            </table>
            <p class="Body">Character classes respect the setting of the Case Sensitive checkbox in the Find &amp; Replace dialog. For example, if Case Sensitive is on, <em class="Code">[a]</em> will only match "a"; if Case Sensitive is off, <em class="Code">[a]</em> will match both "a" and "A".</p>
        </div>
        <div>
            <h4>Matching Non-Printing Characters</h4>
            <p class="Body">As described in Chapter 7 on searching, TextWrangler provides several special character pairs that you can use to match common non-printing characters, as well as the ability to specify any arbitrary character by means of its hexadecimal character code (escape code). You can use these special characters in grep patterns as well as for normal searching.</p>
            <p class="Body">For example, to look for a tab or a space, you would use the character class [\t ] (consisting of a tab special character and a space character).</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Character</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\r</p>
                    </td>
                    <td>
                        <p class="CellBody">line break (carriage return)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\n</p>
                    </td>
                    <td>
                        <p class="CellBody">Unix line break (line feed)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\t</p>
                    </td>
                    <td>
                        <p class="CellBody">tab</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\f</p>
                    </td>
                    <td>
                        <p class="CellBody">page break (form feed)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\a</p>
                    </td>
                    <td>
                        <p class="CellBody">alarm (hex 07)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\cX</p>
                    </td>
                    <td>
                        <p class="CellBody">a named control character, like \cC for Control-C</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\b</p>
                    </td>
                    <td>
                        <p class="CellBody">backspace (hex 08) (only in character classes)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\e</p>
                    </td>
                    <td>
                        <p class="CellBody">Esc (hex 1B)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\xNN</p>
                    </td>
                    <td>
                        <p class="CellBody">hexadecimal character code NN (for example, \x0D for CR)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\x{NNNN}</p>
                    </td>
                    <td>
                        <p class="CellBody">any number of hexadecimal characters NN... (for example, \x{0} will match a null, \x{304F} will match a Japanese Unicode character)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\\</p>
                    </td>
                    <td>
                        <p class="CellBody">backslash</p>
                    </td>
                </tr>
            </table>
            <p class="Body">Use \r to match a line break in the middle of a pattern and the special characters ^ and $ (described above) to "anchor" a pattern to the beginning of a line or to the end of a line. In the case of ^ and $, the line break character is not included in the match.</p>
        </div>
        <div>
            <h4>Other Special Character Classes</h4>
            <p class="Body">TextWrangler uses several other sequences for matching different types or categories of characters.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Special Character</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\s</p>
                    </td>
                    <td>
                        <p class="CellBody">any whitespace character (space, tab, carriage return, line feed, form feed)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\S</p>
                    </td>
                    <td>
                        <p class="CellBody">any non-whitespace character (any character not included by \s)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\w</p>
                    </td>
                    <td>
                        <p class="CellBody">any word character (a-z, A-Z, 0-9, _, and some 8-bit characters)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\W</p>
                    </td>
                    <td>
                        <p class="CellBody">any non-word character (all characters not included by \w, including carriage returns)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\d</p>
                    </td>
                    <td>
                        <p class="CellBody">any digit (0-9)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\D</p>
                    </td>
                    <td>
                        <p class="CellBody">any non-digit character (including carriage return)</p>
                    </td>
                </tr>
            </table>
            <p class="Body">A "word" is defined in TextWrangler as any run of non-word-break characters bounded by word breaks. Word characters are generally alphanumeric, and some characters whose value is greater than 127 are also considered word characters.</p>
            <p class="Body">Note that any character matched by \s is by definition not a word character; thus, anything matched by \s will also be matched by \W (but not the reverse!).</p>
        </div>
        <div>
        
            <h4 id="Heading2">
            Quantifiers Repeat Subpatterns</h4>
            <p class="Body">The special characters <em class="Code">*</em> , <em class="Code">+</em> , and <em class="Code">?</em> specify how many times the pattern preceding them may repeat. <em class="Code">{}</em> -style quantifiers allow you to specify exactly how many times a subpattern can repeat. The preceding pattern can be a literal character, a wildcard character, a character class, or a special character.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">p*</p>
                    </td>
                    <td>
                        <p class="CellBody">zero or more p's</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">p+</p>
                    </td>
                    <td>
                        <p class="CellBody">one or more p's</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">p?</p>
                    </td>
                    <td>
                        <p class="CellBody">zero or one p's</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">p{COUNT}</p>
                    </td>
                    <td>
                        <p class="CellBody">match exactly COUNT p's, where COUNT is an integer</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">p{MIN,}</p>
                    </td>
                    <td>
                        <p class="Note-Text">match at least MIN p's, where MIN is an integer</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">p{MIN, MAX}</p>
                    </td>
                    <td>
                        <p class="CellBody">match at least MIN p's, but no more than MAX</p>
                    </td>
                </tr>
            </table>
            <p class="Body">Note that the repetition characters * and ? match zero or more occurrences of the pattern. That means that they will always succeed, because there will always be at least zero occurrences of any pattern, but that they will not necessarily select any text (if no occurrences of the preceding pattern are present).</p>
            <p class="Body">For this reason, when you are trying to match more than one occurrence, it is usually better to use a <em class="Code">+</em> than a <em class="Code">*</em> , because <em class="Code">+</em> requires a match, whereas <em class="Code">*</em> can match the empty string. Only use <em class="Code">*</em> when you are sure that you really mean "zero or more times," not just "more than once."</p>
            <p class="Body">Try the following examples to see how their behavior matches what you expect:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Text</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">.*</p>
                    </td>
                    <td>
                        <p class="CellBody">Fourscore and seven years</p>
                    </td>
                    <td>
                        <p class="CellBody">Fourscore and seven years</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[0-9]+</p>
                    </td>
                    <td>
                        <p class="CellBody">I've been a loyal member since 1983 or so.</p>
                    </td>
                    <td>
                        <p class="CellBody">1983</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\d+</p>
                    </td>
                    <td>
                        <p class="CellBody">I've got 12 years on him.</p>
                    </td>
                    <td>
                        <p class="CellBody">12</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">A+</p>
                    </td>
                    <td>
                        <p class="CellBody">BAAAAAAAB</p>
                    </td>
                    <td>
                        <p class="CellBody">AAAAAAA</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">A{3}</p>
                    </td>
                    <td>
                        <p class="CellBody">BAAAAB</p>
                    </td>
                    <td>
                        <p class="CellBody">AAA (first three A's)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">A{3,}</p>
                    </td>
                    <td>
                        <p class="CellBody">BAAAAB</p>
                    </td>
                    <td>
                        <p class="CellBody">AAAA</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">A{1,3}</p>
                    </td>
                    <td>
                        <p class="CellBody">BAAAAB</p>
                    </td>
                    <td>
                        <p class="CellBody">AAA on the first match, the remaining A on the second match</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">c?andy</p>
                    </td>
                    <td>
                        <p class="CellBody">andy likes candy</p>
                    </td>
                    <td>
                        <p class="CellBody">"andy" on the first match, "candy" on the second</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">A+</p>
                    </td>
                    <td>
                        <p class="CellBody">Ted joined AAA yesterday</p>
                    </td>
                    <td>
                        <p class="CellBody">"AAA" on the first match; "a" from "yesterday" on the second</p>
                    </td>
                </tr>
            </table>
        </div>
        <div>
            <h4>Combining Patterns to Make Complex Patterns</h4>
            <p class="Body">So far, the patterns you have seen match a single character or the repetition of a single character or class of characters. This is very useful when you are looking for runs of digits or single letters, but often that is not enough.</p>
            <p class="Body">However, by combining these patterns, you can search for more complex items. As it happens, you are already familiar with combining patterns. Remember the section at beginning of this discussion that said that each individual character is a pattern that matches itself? When you search for a word, you are already combining basic patterns.</p>
            <p class="Body">You can combine any of the preceding grep patterns in the same way. Here are some examples.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                    <th>
                        <p class="CellHeading">Examples</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\d+\+\d+</p>
                    </td>
                    <td>
                        <p class="CellBody">a string of digits, followed by a literal plus sign, followed by more digits</p>
                    </td>
                    <td>
                        <p class="CellBody">4+2</p>
                        <p class="CellBody">1234+5829</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\d{4}[\t ]B\.C\.</p>
                    </td>
                    <td>
                        <p class="CellBody">four digits, followed by a tab or a space, followed by the string B.C.</p>
                    </td>
                    <td>
                        <p class="CellBody">2152 B.C.</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\$?[0-9,]+\.\d*</p>
                    </td>
                    <td>
                        <p class="CellBody">an optional dollar sign, followed by one or more digits and commas, followed by a period, then zero or more digits</p>
                    </td>
                    <td>
                        <p class="CellBody">1,234.56<br />
                        $4,296,459.19<br />
                        $3,5,6,4.0000<br />
                        0. (oops!)</p>
                    </td>
                </tr>
            </table>
            <p class="Body">Note again in these examples how the characters that have special meaning to grep are preceded by a backslash (\+, \., and \$) when we want them to match themselves.</p>
        </div>
        <div>
            <h4>Creating Subpatterns</h4>
            <p class="Body">Subpatterns provide a means of organizing or grouping complex grep patterns. This is primarily important for two reasons: for limiting the scope of the alternation operator (which otherwise creates an alternation of everything to its left and right), and for changing the matched text when performing replacements.</p>
            <p class="Body">A subpattern consists of any simple or complex pattern, enclosed in a pair of parentheses. You can optionally specify a simple string to identify a subpattern, making it a named subpattern.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(p)</p>
                    </td>
                    <td>
                        <p class="CellBody">the pattern p and remembers it</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(?P&lt;NAME&gt;p)</p>
                    </td>
                    <td>
                        <p class="CellBody">the pattern p and remembers it by the specified string NAME</p>
                    </td>
                </tr>
            </table>
            <p class="Body">You can combine more than one subpattern into a grep pattern, or mix subpatterns and other pattern elements as you need.</p>
            <p class="Body">Taking the last set of examples, you could modify these to use subpatterns wherever actual data appears:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                    <th>
                        <p class="CellHeading">Examples</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(\d+)\+(\d+)</p>
                    </td>
                    <td>
                        <p class="CellBody">a string of digits, followed by a plus sign, followed by more digits</p>
                    </td>
                    <td>
                        <p class="CellBody">4+2<br />
                        1234+5829</p>
                        <p class="CellBody">&nbsp;</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(\d{4})[\t ]B\.C\.</p>
                    </td>
                    <td>
                        <p class="CellBody">four digits, followed by a tab or a space, followed by the string B.C.</p>
                    </td>
                    <td>
                        <p class="CellBody">2152 B.C.</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\$?([0-9,]+)\.(\d*)</p>
                    </td>
                    <td>
                        <p class="CellBody">an optional dollar sign, followed by one or more digits and commas, followed by a period, then zero or more digits</p>
                    </td>
                    <td>
                        <p class="CellBody">1,234.56<br />
                        $4,296,459.19<br />
                        $3,5,6,4.0000<br />
                        0.</p>
                    </td>
                </tr>
            </table>
        </div>
        <div>
            <h4>Using Backreferences in Subpatterns</h4>
            <p class="Body">What if we wanted to match a series of digits, followed by a plus sign, followed by the exact same series of digits as on the left side of the plus? In other words, we want to match "1234+1234" or "7+7", but not "5432+1984".</p>
            <p class="Body">Using grouping parentheses, you can do this by referring to a backreference, also known as a captured subpattern. There are two kinds of backreferences: numbered backreferences, and named backreferences. You can use both types of backreference within the same grep pattern.</p>
            <p class="Body">Each subpattern within the complete pattern is numbered from left to right, starting with the opening parenthesis. Later in the pattern, you can refer to the text matched within any of these subpatterns by using a backslash followed by the number of that subpattern; this is a numbered backreference. Unlike numbered backreferences, which are automatically identified from the pattern, named backreferences are only available after you define them.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches...</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\1, \2, ..., \99</p>
                    </td>
                    <td>
                        <p class="CellBody">the text of the nth subpattern in the entire search pattern</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(?P=NAME)</p>
                    </td>
                    <td>
                        <p class="CellBody">the text of the subpattern NAME</p>
                    </td>
                </tr>
            </table>
            <p class="Body">&nbsp;</p>
            <p class="Body">Names may include alphanumeric characters and underscores, and must be unique within a pattern.</p>
            <p class="Body">&nbsp;</p>
            <p class="Body">&nbsp;</p>
            <p class="Body">Here are some examples of numbered backreferences:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches</p>
                    </th>
                    <th>
                        <p class="CellHeading">Examples</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(\d+)\+\1</p>
                    </td>
                    <td>
                        <p class="CellBody">a string of digits, followed by a plus sign, followed the same digits</p>
                    </td>
                    <td>
                        <p class="CellBody">7+7<br />
                        1234+1234</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(\w+)\s+\1</p>
                    </td>
                    <td>
                        <p class="CellBody">double words</p>
                    </td>
                    <td>
                        <p class="CellBody">the the</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(\w)(\w)\2\1</p>
                    </td>
                    <td>
                        <p class="CellBody">a word character, a second word character, followed by the second one again and the first one again</p>
                    </td>
                    <td>
                        <p class="CellBody">abba</p>
                    </td>
                </tr>
            </table>
            <p class="Body">We will revisit subpatterns in the section on replacement, where you will see how the choice of subpatterns affects the changes you can make.</p>
        </div>
        <div>
            <h4>Using Alternation</h4>
            <p class="Body">The alternation operator | allows you to match any of several patterns at a given point. To use this operator, place it between one or more patterns x|y to match either x or y.</p>
            <p class="Body">As with all of the preceding options, you can combine alternation with other pattern elements to handle more complex searches.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Text is...</p>
                    </th>
                    <th>
                        <p class="CellHeading">Matches...</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">a|t</p>
                    </td>
                    <td>
                        <p class="CellBody">A cat</p>
                    </td>
                    <td>
                        <p class="CellBody">each "a" and "t"</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">a|c|t</p>
                    </td>
                    <td>
                        <p class="CellBody">A cat</p>
                    </td>
                    <td>
                        <p class="CellBody">each "a", "c", and "t"</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">a (cat|dog) is</p>
                    </td>
                    <td>
                        <p class="CellBody">A cat is here. A dog is here. A giraffe is here.</p>
                    </td>
                    <td>
                        <p class="CellBody">"A cat is", "A dog is"</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">A|b+</p>
                    </td>
                    <td>
                        <p class="CellBody">Abba</p>
                    </td>
                    <td>
                        <p class="CellBody">"A", "bb", and "a"</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">Andy|Ted</p>
                    </td>
                    <td>
                        <p class="CellBody">Andy and Ted joined AAA yesterday</p>
                    </td>
                    <td>
                        <p class="CellBody">"Andy" and "Ted"</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\d{4}|years</p>
                    </td>
                    <td>
                        <p class="CellBody">I've been a loyal member since 1983, almost 16 years ago.</p>
                    </td>
                    <td>
                        <p class="CellBody">"1983", "years"</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">[a-z]+|\d+</p>
                    </td>
                    <td>
                        <p class="CellBody">That's almost 16 years.</p>
                    </td>
                    <td>
                        <p class="CellBody">"That", "s", "almost", "16", "years"</p>
                    </td>
                </tr>
            </table>
        </div>
        <div>
            <h4>The "Longest Match" Issue</h4>
            <div>
                <h6 class="Note-Head">IMPORTANT</h6>
                <p class="Body">When creating complex patterns, you should bear in mind that the quantifiers <em class="Code">+</em> , <em class="Code">*</em> , <em class="Code">?</em> and <em class="Code">{}</em> are "greedy." That is, they will always make the longest possible match possible to a given pattern, so if your pattern is E+ (one or more E's) and your text contains "EEEE", the pattern matches all the E's at once, not just the first one. This is usually what you want, but not always.</p>
                <p class="Body">Suppose, for instance, that you want to match an HTML tag. At first, you may think that a good way to do this would be to search for the pattern:</p>
                <p class="Code-Indented">&lt;.+&gt;</p>
                <p class="Body">consisting of a less-than sign, followed by one or more occurrences of a single character, followed by a greater-than sign. To understand why this may not work the way you think it should, consider the following sample text to be searched:</p>
                <p class="Code-Indented">&lt;B&gt;This text is in boldface.&lt;/B&gt;</p>
                <p class="Body">The intent was to write a pattern that would match both of the HTML tags separately. Let's see what actually happens. The &lt; character at the beginning of this line matches the beginning of the pattern. The next character in the pattern is . which matches any character (except a line break), modified with the + quantifier, taken together, this combination means one or more repetitions of any character. That, of course, takes care of the B. The problem is that the next &gt; is also "any character" and that it also qualifies as "one or more repetitions." In fact, all of the text up to the end of the line qualifies as "one or more repetitions of any character" (the line break does not qualify, so grep stops there). After grep has reached the line break, it has exhausted the + operator, so it backs up and sees if it can find a match for &gt;. Lo and behold, it can: the last character is a greater-than symbol. Success!</p>
                <p class="Body">In other words, the pattern matches our entire sample line at once, not the two separate HTML tags in it as we intended. More generally, the pattern matches all the text in a given line or paragraph from the first &lt; to the last &gt;. The pattern only does what we intended when there is only one HTML tag in a line or paragraph. This is what we meant when we say that the regular quantifiers try to make the longest possible match.</p>
            </div>
        </div>
        <div>
            <h4>Non-Greedy Quantifiers</h4>
            <div>
                <h6 class="Note-Head">IMPORTANT</h6>
                <p class="Body">To work around this "longest match" behavior, you can modify your pattern to take advantage of non-greedy quantifiers.</p>
                <table>
                    <tr>
                        <th>
                            <p class="CellHeading">Quantifier</p>
                        </th>
                        <th>
                            <p class="CellHeading">Matches...</p>
                        </th>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">+?</p>
                        </td>
                        <td>
                            <p class="CellBody">one or more</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">*?</p>
                        </td>
                        <td>
                            <p class="CellBody">zero or more</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">??</p>
                        </td>
                        <td>
                            <p class="CellBody">zero or one</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">{COUNT}?</p>
                        </td>
                        <td>
                            <p class="CellBody">match exactly COUNT times</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">{MIN,}?</p>
                        </td>
                        <td>
                            <p class="Note-Text">match at least MIN times</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="Code">{MIN, MAX}?</p>
                        </td>
                        <td>
                            <p class="CellBody">match at least MIN times, but no more than MAX</p>
                        </td>
                    </tr>
                </table>
                <p class="Body">Astute readers will note that these non-greedy quantifiers correspond exactly to their normal (greedy) counterparts, appended with a question mark.</p>
                <p class="Body">Revisiting our problem of matching HTML tags, for example, we can search for:</p>
                <p class="Code-Indented">&lt;.+?&gt;</p>
                <p class="Body">This matches an opening bracket, followed by one or more occurrences of any character other than a return, followed by a closing bracket. The non-greedy quantifier achieves the results we want, preventing TextWrangler from "overrunning" the closing angle bracket and matching across several tags.</p>
                <p class="Body">A slightly more complicated example: how could you write a pattern that matches all text between &lt;B&gt; and &lt;/B&gt; HTML tags? Consider the sample text below:</p>
                <p class="Code-Indented">&lt;B&gt;Welcome&lt;/B&gt; to the home of &lt;B&gt;TextWrangler!&lt;/B&gt;</p>
                <p class="Body">As before, you might be tempted to write:</p>
                <p class="Code-Indented">&lt;B&gt;.*&lt;/B&gt;</p>
                <p class="Body">but for the same reasons as before, this will match the entire line of text. The solution is similar; we will use the non-greedy <em class="Code">*?</em> quantifier:</p>
                <p class="Code-Indented">&lt;B&gt;.*?&lt;/B&gt;</p>
            </div>
        </div>
    </div>
    <div>
        <hr />
        <h3 id="ReplacePatterns">Writing Replacement Patterns</h3>
        <div>
            <h4>Subpatterns Make Replacement Powerful</h4>
            <p class="Body">We covered subpatterns earlier when discussing search patterns and discussed how the parentheses can be used to limit the scope of the alternation operator. Another reason for employing subpatterns in your grep searches is to provide a powerful and flexible way to change or reuse found information as part of a search-and-replace operation. If you do not use subpatterns, you can still access the complete results of the search with the &amp; metacharacter. However, this precludes reorganizing the matched data as it is replaced.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Pattern</p>
                    </th>
                    <th>
                        <p class="CellHeading">Inserts...</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">&amp;</p>
                    </td>
                    <td>
                        <p class="CellBody">the text matched by the entire search pattern</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\1, \2, ..., \99</p>
                    </td>
                    <td>
                        <p class="CellBody">the text matched by the nth subpattern of the entire search pattern</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">\P&lt;NAME&gt;</p>
                    </td>
                    <td>
                        <p class="CellBody">the text matched by the subpattern NAME</p>
                    </td>
                </tr>
            </table>
            <div>
                <p class="Note-Head">Note</p>
                <p class="Note-Text">TextWrangler will remember up to 99 backreferenced subpatterns. Versions prior to 3.0 were limited to 9 subpatterns.</p>
            </div>
        </div>
        <div>
            <h4>Using the Entire Matched Pattern</h4>
            <p class="Body">The &amp; character is useful when you want to use the entire matched string as the basis of a replacement. Suppose that in your text every instance of product names that begin with the company name "ACME" needs to end with a trademark symbol (?). The following search pattern finds two-word combinations that begin with "ACME":</p>
            <p class="Code-Indented">ACME [A-Za-z]+</p>
            <p class="Body">The following replacement string adds the trademark symbol to the matched text:</p>
            <p class="Code-Indented">&amp;&trade;</p>
            <p class="Body">For example, if you start with</p>
            <p class="Code-Indented">ACME Magnets, ACME Anvils, and ACME TNT are all premium products.</p>
            <p class="Body">and perform a replace operation with the above patterns, you will get:</p>
            <p class="Code-Indented">ACME Magnets&trade;, ACME Anvils&trade;, and ACME TNT&trade; are all premium products.</p>
        </div>
        <div>
            <h4>Using Parts of the Matched Pattern</h4>
            <p class="Body">While using the entire matched pattern in a replacement string is useful, it is often more useful to use only a portion of the matched pattern and to rearrange the parts in the replacement string.</p>
            <p class="Body">For example, suppose a source file contains C-style declarations of this type:</p>
            <p class="Code-Indented">#define Util_Menu 284<br />
            #define Tool_Menu 295</p>
            <p class="Body">and you want to convert them so they look like this, Pascal-style:</p>
            <p class="Code-Indented">const int Util_Menu = 284;<br />
            const int Tool_Menu = 295;</p>
            <p class="Body">The pattern to find the original text is straightforward:</p>
            <p class="Code-Indented">#define[ \t]+.+[ \t]+\d+[^0-9]*$</p>
            <p class="Body">This pattern matches the word "#define" followed by one or more tabs or spaces, followed by one or more characters of any type, followed by one or more tabs or spaces, followed by one or more digits, followed by zero or more characters that are not digits (to allow for comments), followed by the end of the line.</p>
            <p class="Body">The problem with this pattern is that it matches the entire line. It does not provide a way to remember the individual parts of the found string.</p>
            <p class="Body">If you use subpatterns to rewrite the above search pattern slightly, you get this:</p>
            <p class="Code-Indented">#define[ \t]+(.+)[ \t]+(\d+)[^0-9]*$</p>
            <p class="Body">The first set of parentheses defines a subpattern which remembers the name of the constant. The second set remembers the value of the constant.</p>
            <p class="Body">The replacement string would look like this:</p>
            <p class="Code-Indented">const int \1 = \2;</p>
            <p class="Body">The sequence <em class="Code">\1</em> is replaced by the name of the constant (the first subpattern from the search pattern), and the sequence <em class="Code">\2</em> is replaced by the value of the constant (from the second subpattern).</p>
            <p class="Body">Our example throws out any comment that may follow the C-style constant declaration. As an exercise, try rewriting the search and replace patterns so they preserve the comment, enclosing it in (*...*) style Pascal comment markers.</p>
            <p class="Body">Here are some more examples:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Data</p>
                    </th>
                    <th>
                        <p class="CellHeading">Search for</p>
                    </th>
                    <th>
                        <p class="CellHeading">Replace</p>
                    </th>
                    <th>
                        <p class="CellHeading">Result</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">4+2</p>
                    </td>
                    <td>
                        <p class="CellBody">(\d+)\+(\d+)</p>
                    </td>
                    <td>
                        <p class="CellBody">\2+\1</p>
                    </td>
                    <td>
                        <p class="CellBody">2+4</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">1234+5829</p>
                    </td>
                    <td>
                        <p class="CellBody">(\d+)\+(\d+)</p>
                    </td>
                    <td>
                        <p class="CellBody">\1+\1</p>
                    </td>
                    <td>
                        <p class="CellBody">1234+1234</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">2152 B.C.</p>
                    </td>
                    <td>
                        <p class="CellBody">(\d{4})[\t ]B\.C\.</p>
                    </td>
                    <td>
                        <p class="CellBody">\1 A.D.</p>
                    </td>
                    <td>
                        <p class="CellBody">2152 A.D.</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">1,234.56</p>
                    </td>
                    <td>
                        <p class="CellBody">\$?([0-9,]+)\.(\d+)</p>
                    </td>
                    <td>
                        <p class="CellBody">\1 dollars and \2 cents</p>
                    </td>
                    <td>
                        <p class="CellBody">1,234 dollars and 56 cents</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">$4,296,459.19</p>
                    </td>
                    <td>
                        <p class="CellBody">\$?([0-9,]+)\.(\d+)</p>
                    </td>
                    <td>
                        <p class="CellBody">\1 dollars and \2 cents</p>
                    </td>
                    <td>
                        <p class="CellBody">4,296,459 dollars and 19 cents</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">$3,5,6,4.00000</p>
                    </td>
                    <td>
                        <p class="CellBody">\$?([0-9,]+)\.(\d+)</p>
                    </td>
                    <td>
                        <p class="CellBody">\1 dollars and \2 cents</p>
                    </td>
                    <td>
                        <p class="CellBody">3,5,6,4 dollars and 00000 cents</p>
                    </td>
                </tr>
            </table>
        </div>
        <div>
            <h4>Case Transformations</h4>
            <p class="Body">Replace patterns can also change the case of the original text when using subpattern replacements. The syntax is similar to Perl's, specifically:</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Modifier</p>
                    </th>
                    <th>
                        <p class="CellHeading">Effect</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\u</p>
                    </td>
                    <td>
                        <p class="CellBody">Make the next character uppercase</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\U</p>
                    </td>
                    <td>
                        <p class="CellBody">Make all following characters uppercase until reaching another case specifier (\u, \L, \l ) or \E</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\l</p>
                    </td>
                    <td>
                        <p class="CellBody">Make the next character lowercase</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\L</p>
                    </td>
                    <td>
                        <p class="CellBody">Make all following characters lowercase until reaching another case specifier (\u, \U, \l ) or \E</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">\E</p>
                    </td>
                    <td>
                        <p class="CellBody">End case transformation opened by \U or \L</p>
                    </td>
                </tr>
            </table>
            <p class="Body">Here are some examples to illustrate how case transformations can be used.</p>
            <p class="Body">Given some text:</p>
            <p class="Code-Indented">mumbo-jumbo</p>
            <p class="Body">and the search pattern:</p>
            <p class="Code-Indented">(\w+)(\W)(\w+)</p>
            <p class="Body">the following replace patterns will produce the following output:</p>
            <p class="Code-Indented-No-Space">\U\1\E\2\3 MUMBO-jumbo</p>
            <p class="Code-Indented">\u\1\2\u\3 Mumbo-Jumbo</p>
            <p class="Body">Note that case transformations also affect literal strings in the replace pattern:</p>
            <p class="Code-Indented-No-Space">\U\1\2fred MUMBO-FRED</p>
            <p class="Code-Indented">\lMUMBLE\2\3 mUMBLE-jumbo</p>
            <p class="Body">Finally, note that \E is not necessary to close off a modifier; if another modifier appears before an \E is encountered, that modifier will take effect immediately:</p>
            <p class="Code-Indented">\Ufred-\uwilma FRED-Wilma</p>
        </div>
    </div>
    <div>

        <hr />
        <h3 id="Examples">Examples</h3>
        <p class="Body">The example patterns in this section describe some common character classes and shortcuts used for constructing grep patterns, and addresses some common tasks that you might find useful in your work.</p>
        <div>
            <h4>Matching Identifiers</h4>
            <p class="Body">One of the most common things you will use grep patterns for is to find and modify identifiers, such as variables in computer source code or object names in HTML source documents. To match an arbitrary identifier in most programming languages, you might use this search pattern:</p>
            <p class="Code-Indented">[a-z][a-zA-Z0-9]*</p>
            <p class="Body">This pattern matches any sequence that begins with a lowercase letter and is followed by zero or more alphanumeric characters. If other characters are allowed in the identifier, add them to the pattern. This pattern allows underscores in only the first character of the identifier:</p>
            <p class="Code-Indented">[a-z_][a-zA-Z0-9]*</p>
            <p class="Body">The following pattern allows underscores anywhere but the first character, but allows identifiers to begin with an uppercase or lowercase letter:</p>
            <p class="Code-Indented">[a-zA-Z][a-zA-Z0-9_]*</p>
        </div>
        <div>
            <h4>Matching White Space</h4>
            <p class="Body">Often you will want to match two sequences of data that are separated by tabs or spaces, whether to simply identify them, or to rearrange them.</p>
            <p class="Body">For example, suppose you have a list of formatted label-data pairs like this:</p>
            <p class="Code-Indented">User name: Bernard Rubble<br />
            Occupation: Actor<br />
            Spouse: Betty</p>
            <p class="Body">You can see that there are tabs or spaces between the labels on the left and the data on the right, but you have no way of knowing how many spaces or tabs there will be on any given line. Here is a character class that means "match one or more white space characters."</p>
            <p class="Code-Indented">[ \t]+</p>
            <p class="Body">So, if you wanted to transform the list above to look like this:</p>
            <p class="Code-Indented">User name("Bernard Rubble")<br />
            Occupation("Actor")<br />
            Spouse("Betty")</p>
            <p class="Body">You would use this search pattern:</p>
            <p class="Code-Indented">([a-z ]+):[ \t]+([a-z ]+)</p>
            <p class="Body">and this replacement pattern:</p>
            <p class="Code-Indented">\1\("\2"\)</p>
        </div>
        <div>
            <h4>Matching Delimited Strings</h4>
            <p class="Body">In some cases, you may want to match all the text that appears between a pair of delimiters. One way to do this is to bracket the search pattern with the delimiters, like this:</p>
            <p class="Code-Indented">".*"</p>
            <p class="Body">This works well if you have only one delimited string on the line. But suppose the line looked like this:</p>
            <p class="Code-Indented">"apples", "oranges, kiwis, mangos", "penguins"</p>
            <p class="Body">The search string above would match the entire line. (This is another instance of the "longest match" behavior of TextWrangler's grep engine, which was discussed previously.)</p>
            <p class="Body">Once again, non-greedy quantifiers come to the rescue. The following pattern will match "-delimited strings:</p>
            <p class="Code-Indented">".+?"</p>
        </div>
        <div>
            <h4>Marking Structured Text</h4>
            <p class="Body">Suppose you are reading a long text document that does not have a table of contents, but you notice that all the sections are numbered like this:</p>
            <p class="Code-Indented">3.2.7 Prehistoric Cartoon Communities<br />
            5.19.001 Restaurants of the Mesozoic</p>
            <p class="Body">You can use a grep pattern to create marks for these headings, which will appear in the Mark popup menu. Choose Find &amp; Mark All from the Mark popup menu in the navigation bar. Then, decide how many levels you want to mark. In this example, the headings always have at least two digits and at most four.</p>
            <p class="Body">Use this pattern to find the headings:</p>
            <p class="Code-Indented">^(\d+\.\d+\.?\d*\.?\d*)[ \t]+([a-z ]+)</p>
            <p class="Body">and this pattern to make the file marks:</p>
            <p class="Code-Indented">\1 \2</p>
            <p class="Body">The <em class="Code">^</em> before the first search group ensures that TextWrangler matches the numeric string at the beginning of a line. The pattern</p>
            <p class="Code-Indented">\.?\d*</p>
            <p class="Body">matches a (possible) decimal point and a digit sequence. The other groups use the white space idiom and the identifier idiom. You can use a similar technique to mark any section that has a section mark that can be described with grep.</p>
        </div>
        <div>
            <h4>Marking a Mail Digest</h4>
            <p class="Body">You can elaborate the structured text technique to create markers for mail digests. Assume that each digest is separated by the following lines:</p>
            <p class="Code-Indented">From: Sadie Burke &lt;sadie@burke.com&gt;<br />
            Date: Sun, 16 Jul 1995 13:17:45 -0700<br />
            Subject: Fishing with the judge</p>
            <p class="Body">Suppose you want the marker text to list the subject and the sender. You would use the following search string:</p>
            <p class="Code-Indented">^From:[ \t]+(.*)\r.*\rSubject:[ \t]+(.*)</p>
            <p class="Body">And mark the text with this replacement string:</p>
            <p class="Code-Indented">\2 \1</p>
            <p class="Body">Note that for the sequence \r.*\r in the middle of the search string, the \r before "Subject" is necessary because as previously discussed, the special character . does not match carriage returns. (At least, not by default. See "<a href="#AdvancedTopics">Advanced Topics</a>," below, for details on how to make dot match any character, including carriage returns.)</p>
        </div>
        <div>
            <h4>Rearranging Name Lists</h4>
            <p class="Body">You can use grep patterns to transform a list of names in first name first form to last name first order (for a later sorting, for instance). Assume that the names are in the form:</p>
            <p class="Code-Indented">Junior X. Potter<br />
            Jill Safai<br />
            Dylan Schuyler Goode<br />
            Walter Wang</p>
            <p class="Body">If you use this search pattern:</p>
            <p class="Code-Indented">^(.*) ([^ ]+)$</p>
            <p class="Body">And this replacement string:</p>
            <p class="Code-Indented">\2, \1</p>
            <p class="Body">The transformed list becomes:</p>
            <p class="Code-Indented">Potter, Junior X.<br />
            Safai, Jill<br />
            Goode, Dylan Schuyler<br />
            Wang, Walter</p>
        </div>
    </div>
    <div>
        <hr />
        
        <h3 id="AdvancedTopics">Advanced Topics</h3>
        <p class="Body">TextWrangler's PCRE-based grep engine offers unparalleled syntactical power. The topics below cover areas that show how grep can effectively match very complicated patterns of text--matches which were impossible to achieve with older versions of TextWrangler. However, with this power comes complexity.</p>
        <p class="Body">If you are new to grep, it is possible that the topics covered in this section will not make much sense to you. That's OK. The best way to learn grep is to use it in real life, not by reading example patterns. In many cases, the basic grep syntax covered previously in this chapter will be all that you need.</p>
        <p class="Body">If you are an experienced user of grep, however, many of the topics covered below will be of great interest.</p>
        <div>
            <h4>Matching Nulls</h4>
            <p class="Body">The grep engine used in versions of TextWrangler prior to 3.0 was unable to search text that contained null characters (ASCII value zero), but this limitation has since been removed. Here's one way to match a null:</p>
            <p class="Code-Indented">\x{0}</p>
        </div>
        <div>
            <h4>Backreferences</h4>
            <p class="Body">The following charts explain the rules TextWrangler uses for determining backreferences.</p>
            <div>
                <h4>In Search Patterns</h4>
                <table>
                    <tr>
                        <th>
                            <p class="CellHeading">Modifier</p>
                        </th>
                        <th>
                            <p class="CellHeading">Effect</p>
                        </th>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\0</p>
                        </td>
                        <td>
                            <p class="CellBody">A backslash followed by a zero is an octal character reference. Up to two further octal characters are read. Thus, "\040" will match a space character, and "\07" will match the ASCII BEL (\x07), but "\08" will match an ASCII null followed by the digit 8 (because octal characters only range from 0-7).</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\1-9</p>
                        </td>
                        <td>
                            <p class="CellBody">A backslash followed by a single decimal digit from 1 to 9 is always a backreference to the Nth captured subpattern.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\10-99</p>
                        </td>
                        <td>
                            <p class="CellBody">A backslash followed by two decimal digits, which taken together form the integer N (ranging from 10 to 99), is a backreference to the Nth captured subpattern, if there exist N capturing sets of parentheses in the pattern. If there are fewer than N captured subpatterns, the grep engine will instead look for up to three octal digits following the backslash. Any subsequent digits stand for themselves.</p>
                            <p class="CellBody">So, in a search pattern, "\11" is a backreference if there are 11 or more sets of capturing parentheses in the pattern. If not, it matches a tab. "\011" always matches a tab. "\81" is a backreference if there are 81 or more captured subpatterns, but matches an ASCII null followed by the two characters "8" and "1" otherwise.</p>
                            <p class="CellBody">&nbsp;</p>
                        </td>
                    </tr>
                </table>
            </div>
            <div>
                <h4>In Character Classes</h4>
                <table>
                    <tr>
                        <th>
                            <p class="CellHeading">Modifier</p>
                        </th>
                        <th>
                            <p class="CellHeading">Effect</p>
                        </th>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\OCTAL</p>
                        </td>
                        <td>
                            <p class="CellBody">Inside a character class, a backslash followed by up to three octal digits generates a single byte character reference from the least significant eight bits of the value. Thus, the character class "[\7]" will match a single byte with octal value 7 (equivalent to "\x07"). "[\8]" will match a literal "8" character.</p>
                        </td>
                    </tr>
                </table>
            </div>
            <div>
                <h4>In Replacement Patterns</h4>
                <table>
                    <tr>
                        <th>
                            <p class="CellHeading">Modifier</p>
                        </th>
                        <th>
                            <p class="CellHeading">Effect</p>
                        </th>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\NNN+</p>
                        </td>
                        <td>
                            <p class="CellBody">If more than two decimal digits follow the backslash, only the first two are considered part of the backreference. Thus, "\111" would be interpreted as the 11th backreference, followed by a literal "1". You may use a leading zero; for example, if in your replacement pattern you want the first backreference followed by a literal "1", you can use "\011". (If you use "\11", you will get the 11th backreference, even if it is empty.)</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\NN</p>
                        </td>
                        <td>
                            <p class="CellBody">If two decimal digits follow the backslash, which taken together represent the value N, and if there is an Nth captured substring, then all three characters are replaced with that substring. If there is not an Nth captured substring, all three characters are discarded--that is, the backreference is replaced with the empty string.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <p class="CellBody">\N</p>
                        </td>
                        <td>
                            <p class="CellBody">If there is only a single digit N following the backslash and there is an Nth captured substring, both characters are replaced with that substring. Otherwise, both characters are discarded--that is, the backreference is replaced with the empty string. In replacement patterns, \0 is a backreference to the entire match (exactly equivalent to "&amp;").</p>
                        </td>
                    </tr>
                </table>
            </div>
        </div>
        <div>
            <h4>POSIX-Style Character Classes</h4>
            <p class="Body">TextWrangler now provides support for POSIX-style character classes. These classes are used in the form <em class="Code">[:CLASS:]</em> , and are only available inside regular character classes (in other words, inside another set of square brackets).</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Class</p>
                    </th>
                    <th>
                        <p class="CellHeading">Meaning</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">alnum</p>
                    </td>
                    <td>
                        <p class="CellBody">letters and digits</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">alpha</p>
                    </td>
                    <td>
                        <p class="CellBody">letters</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">ascii</p>
                    </td>
                    <td>
                        <p class="CellBody">character codes 0-127</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">blank</p>
                    </td>
                    <td>
                        <p class="CellBody">horizontal whitespace</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">cntrl</p>
                    </td>
                    <td>
                        <p class="CellBody">control characters</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">digit</p>
                    </td>
                    <td>
                        <p class="CellBody">decimal digits (same as \d)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">graph</p>
                    </td>
                    <td>
                        <p class="CellBody">printing characters, excluding spaces</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">lower</p>
                    </td>
                    <td>
                        <p class="CellBody">lower case letters</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">print</p>
                    </td>
                    <td>
                        <p class="CellBody">printing characters, including spaces</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">punct</p>
                    </td>
                    <td>
                        <p class="CellBody">punctuation characters</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">space</p>
                    </td>
                    <td>
                        <p class="CellBody">white space (same as \s)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">upper</p>
                    </td>
                    <td>
                        <p class="CellBody">upper case letters</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">word</p>
                    </td>
                    <td>
                        <p class="CellBody">"word" characters (same as \w)</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">xdigit</p>
                    </td>
                    <td>
                        <p class="CellBody">hexadecimal digits</p>
                    </td>
                </tr>
            </table>
            <p class="Body">For example: <em class="Code">[[:digit:]]+</em> is the same as: <em class="Code">[\d]+</em></p>
            <p class="Body">POSIX-style character class names are case-sensitive.</p>
            <p class="Body">It is easy to forget that POSIX-style character classes are only available inside regular character classes. The pattern <em class="Code">[:space:]</em> , without enclosing square brackets, is just a character class consisting of the characters ":", "a", "c", "e", "p", and "s".</p>
            <p class="Body">The names "ascii" and "word" are Perl extensions; the others are defined by the POSIX standard. Another Perl extension supported by TextWrangler is negated POSIX-style character classes, which are indicated by a ^ after the colon. For example, to match any run of non-digit characters:</p>
            <p class="Code-Indented">[[:^digit:]]+</p>
        </div>
        <div>
            <h4>Non-Capturing Parentheses</h4>
            <p class="Body">As described in the preceding section "Creating Subpatterns", bare parentheses cluster and capture the subpatterns they contain. The portion of the matching pattern contained within the first pair of parentheses is available in the backreference \1, the second in \2, and so on.</p>
            <p class="Body">Opening parentheses are counted from left to right to determine the numbers of the captured subpatterns. For example, if the following grep pattern:</p>
            <p class="Code-Indented">((red|white) (king|queen))</p>
            <p class="Body">is matched against the text "red king", the backreferences will be set as follows:</p>
            <p class="Code-Indented-No-Space">\1 "red king"</p>
            <p class="Code-Indented-No-Space">\2 "red"</p>
            <p class="Code-Indented-No-Space">\3 "king"</p>
            <p class="Code-Indented-No-Space">&nbsp;</p>
            <p class="Body">Sometimes, however, parentheses are needed only for clustering, not capturing. TextWrangler now supports non-capturing parentheses, using the syntax:</p>
            <p class="Code-Indented">(?:PATTERN)</p>
            <p class="Body">That is, if an open parenthesis is followed by "?:", the subpattern matched by that pair of parentheses is not counted when computing the backreferences. For example, if the text "red king" is matched against the pattern:</p>
            <p class="Code-Indented">(?:(red|white) (king|queen))</p>
            <p class="Body">the backreferences will be set as follows:</p>
            <p class="Code-Indented">\1 "red"<br />
            \2 "king"</p>
        </div>
        <div>
            <h4>Perl-Style Pattern Extensions</h4>
            <p class="Body">TextWrangler's grep engine supports several extended sequences, which provide grep patterns with super-powers from another universe. Their syntax is in the form:</p>
            <p class="Code-Indented">(?KEY...)</p>
            <p class="Body">in other words, an open parenthesis followed by a question mark, followed by a KEY for the particular grep extension, followed by the rest of the subpattern and a closing parenthesis. This syntax--specifically, an open parenthesis followed by a question mark--was not valid in older versions of TextWrangler, thus, none of these extensions will conflict with old patterns.</p>
            <p class="Body">We have already seen one such extension in the previous section of this document--non-capturing parentheses: (?:...). The remainder are listed in the chart below, and discussed in detail afterward.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Extension</p>
                    </th>
                    <th>
                        <p class="CellHeading">Meaning</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?:...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Cluster-only parentheses, no capturing</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?#...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Comment, discard all text between the parentheses</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?imsx-imsx)</p>
                    </td>
                    <td>
                        <p class="CellBody">Enable/disable pattern modifiers</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?imsx-imsx:...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Cluster-only parens with modifiers</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?=...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Positive lookahead assertion</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?!...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Negative lookahead assertion</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?&lt;=...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Positive lookbehind assertion</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?&lt;!...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Negative lookbehind assertion</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?()...|...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Match with if-then-else</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?()...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Match with if-then</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?&gt;...)</p>
                    </td>
                    <td>
                        <p class="CellBody">Match non-backtracking subpattern ("once-only")</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="CellBody">(?R)</p>
                    </td>
                    <td>
                        <p class="CellBody">Recursive pattern</p>
                    </td>
                </tr>
            </table>
        </div>
        <div>
            <h4>Comments</h4>
            <p class="Body">The sequence <em class="Code">(?#</em> marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part in the pattern matching at all.</p>
            <p class="Code-Indented-No-Space"><em class="Number">Search for:</em> foo(?# Hello, this is a comment)bar<br />
            <em class="Number">Will match:</em> foobar</p>
        </div>
        <div>
            <h4>Pattern Modifiers</h4>
            <p class="Body">The settings for case sensitivity, multi-line matching, whether the dot character can match returns, and "extended syntax" can be turned on and off within a pattern by including sequences of letters between "(?" and ")".</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Modifier</p>
                    </th>
                    <th>
                        <p class="CellHeading">Meaning</p>
                    </th>
                    <th>
                        <p class="CellHeading">Default</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">i</p>
                    </td>
                    <td>
                        <p class="CellBody">case insensitive</p>
                    </td>
                    <td>
                        <p class="CellBody">according to Case Sensitive checkbox in Find &amp; Replace dialog</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">m</p>
                    </td>
                    <td>
                        <p class="CellBody">allow ^ and $ to match at \r</p>
                    </td>
                    <td>
                        <p class="CellBody">on</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">s</p>
                    </td>
                    <td>
                        <p class="CellBody">allow . to match \r</p>
                    </td>
                    <td>
                        <p class="CellBody">off</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">x</p>
                    </td>
                    <td>
                        <p class="CellBody">ignore most white space and allow inline comments in grep patterns</p>
                    </td>
                    <td>
                        <p class="CellBody">off</p>
                    </td>
                </tr>
            </table>
            <p class="Body"><em class="Number">i --</em> By default, TextWrangler obeys the "Case Sensitive" checkbox in the Find &amp; Replace dialog (or the corresponding property of the search options when using the scripting interface). The <em class="Code">(?i)</em> option overrides this setting.</p>
            <p class="Body"><em class="Number">m --</em> By default, TextWrangler's grep engine will match the ^ and $ metacharacters after and before returns, respectively. If you turn this option off with <em class="Code">(?-m)</em> , ^ will only match at the beginning of the document, and $ will only match at the end of the document. (If that is what you want, however, you should consider using the new \A, \Z, and \z metacharacters instead of ^ and $.)</p>
            <p class="Body"><em class="Number">s --</em> By default, the magic dot metacharacter . matches any character except return ("\r"). If you turn this option on with <em class="Code">(?s)</em> , however, dot will match any character. Thus, the pattern <em class="Code">(?s).+</em> will match an entire document.</p>
            <p class="Body"><em class="Number">x --</em> When turned on, this option changes the meaning of most whitespace characters (notably, tabs and spaces) and #. Literal whitespace characters are ignored, and the # character starts a comment that extends until a literal return or the "\r" escape sequence is encountered. Ostensibly, this option intends to let you write more "readable" patterns.</p>
            <p class="Body">Perl programmers should already be familiar with these options, as they correspond directly to the -imsx options for Perl's m// and s/// operators. Unadorned, these options turn their corresponding behavior on; when preceded by a hyphen (-), they turn the behavior off. Setting and unsetting options can occur in the same set of parentheses.</p>
            <table>
                <tr>
                    <th>
                        <p class="CellHeading">Example</p>
                    </th>
                    <th>
                        <p class="CellHeading">Effect</p>
                    </th>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(?imsx)</p>
                    </td>
                    <td>
                        <p class="CellBody">Turn all four options on</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(?-imsx)</p>
                    </td>
                    <td>
                        <p class="CellBody">Turn all four options off</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="Code">(?i-msx)</p>
                    </td>
                    <td>
                        <p class="CellBody">Turn "i" on, turn "m", "s", and "x" off</p>
                    </td>
                </tr>
            </table>
            <p class="Body">The scope of these option changes depends on where in the pattern the setting occurs. For settings that are outside any subpattern, the effect is the same as if the options were set or unset at the start of matching. The following patterns all behave in exactly the same way:</p>
            <p class="Code-Indented-No-Space">(?i)abc</p>
            <p class="Code-Indented-No-Space">a(?i)bc</p>
            <p class="Code-Indented-No-Space">ab(?i)c</p>
            <p class="Code-Indented-No-Space">abc(?i)</p>
            <p class="Code-Indented-No-Space">&nbsp;</p>
            <p class="Body">In other words, all four of the above patterns will match without regard to case. Such "top level" settings apply to the whole pattern (unless there are other changes inside subpatterns). If there is more than one setting of the same option at the top level, the right-most setting is used.</p>
            <p class="Body">If an option change occurs inside a subpattern, the effect is different. An option change inside a subpattern affects only that part of the subpattern that follows it, so, if the "Case Sensitive" checkbox is turned on:</p>
            <p class="Code-Indented-No-Space"><em class="Number">Search for:</em> (a(?i)b)c</p>
            <p class="Code-Indented-No-Space"><em class="Number">Will match:</em> abc or aBc</p>
            <p class="Code-Indented-No-Space">&nbsp;</p>
            <p class="Body">and will not match anything else. (But if "Case Sensitive" is turned off, the "<em class="Code">(?i)</em> " in the above pattern is superfluous and has no effect.) By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</p>
            <p class="Code-Indented-No-Space"><em class="Number">Search for:</em> (a(?i)b|c)</p>
            <p class="Code-Indented-No-Space">&nbsp;</p>
            <p class="Body">matches "ab", "aB", "c", and "C", even though when matching "C", the first branch is abandoned before the option setting.</p>
            <p class="Body">These options can also be set using the clustering (non-capturing) parentheses syntax defined earlier, by inserting the option letters between the "?" and ":". The scope of options set in this manner is limited to the subpattern contained therein. Examples:</p>
            <p class="Code-Indented-No-Space"><em class="Number">Search for:</em> (?i:saturday|sunday)</p>
            <p class="Code-Indented-No-Space"><em class="Number">Will match:</em> SATURDAY or Saturday or SUNday (and so on)</p>
            <p class="Code-Indented-No-Space">&nbsp;</p>
            <p class="Code-Indented-No-Space"><em class="Number">Search for:</em> (?i:foo)(?-i:bar)</p>
            <p class="Code-Indented-No-Space"><em class="Number">Will match:</em> foobar or FOObar</p>
            <p class="Code-Indented-No-Space"><em class="Number">Will not match:</em> FOOBAR or fooBAR</p>
            <p class="Body">&nbsp;</p>
        </div>
        <div>
            <h4>Positional Assertions</h4>
            <p class="Body">Positional assertions "anchor" a pattern, without actually matching any characters. Simple assertions have already been described: those which are invoked with the escape sequences \b, \B, \A, \Z, \z, ^ and $. For example, the pattern <em class="Code">\bfoo\b</em> will only match the string "foo" if it has word breaks on both sides, but the \b's do not themselves match any characters; the entire text matched by this pattern are the three characters "f", "o", and "o".</p>
            <p class="Body">Lookahead and lookbehind assertions work in a similar manner, but allow you to test for arbitrary patterns to anchor next to. If you have ever said to yourself, "I would like to match `foo', but only when it is next to `bar'," lookaround assertions fill that need.</p>
            <p class="Body">Positive lookahead assertions begin with "<em class="Code">(?=</em> ", and negative lookahead assertions begin with "<em class="Code">(?!</em> ". For example:</p>
            <p class="Code-Indented">\w+(?=;)</p>
            <p class="Body">will match any word followed by a semicolon, but the semicolon is not included as part of the match.</p>
            <p class="Code-Indented">foo(?!bar)</p>
            <p class="Body">matches any occurrence of "foo" that is not followed by "bar". Note that the apparently similar pattern:</p>
            <p class="Code-Indented">(?!foo)bar</p>
            <p class="Body">does not find an occurrence of "bar" that is preceded by something other than "foo"; it finds any occurrence of "bar" whatsoever, because the assertion <em class="Code">(?!foo)</em> is always true when the next three characters are "bar". A lookbehind assertion is needed to achieve this effect.</p>
            <p class="Body">Positive lookbehind assertions start with "<em class="Code">(?&lt;=</em> ", and negative lookbehind assertions start with "<em class="Code">(?&lt;!</em> ". For example:</p>
            <p class="Code-Indented">(?&lt;!foo)bar</p>
            <p class="Body">does find an occurrence of "bar" that is not preceded by "foo". The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are several alternatives, they do not all have to have the same fixed length. Thus</p>
            <p class="Code-Indented">(?&lt;=Martin|Lewis)</p>
            <p class="Body">is permitted, but</p>
            <p class="Code-Indented">(?&lt;!dogs?|cats?)</p>
            <p class="Body">causes an error. Branches that match different length strings are permitted only at the top level of a lookbehind assertion. This is different compared with Perl 5.005, which requires all branches to match the same length of string. An assertion such as</p>
            <p class="Code-Indented">(?&lt;=ab(c|de))</p>
            <p class="Body">is not permitted, because its single top-level branch can match two different lengths, but it is acceptable if rewritten to use two top-level branches:</p>
            <p class="Code-Indented">(?&lt;=abc|abde)</p>
            <p class="Body">The implementation of lookbehind assertions is, for each alternative, to temporarily move the current position back by the fixed width and then try to match. If there are insufficient characters before the current position, the match is deemed to fail. (Lookbehinds in conjunction with non-backtracking [a.k.a. "once-only"] subpatterns can be particularly useful for matching at the ends of strings; an example is given in the section on once-only subpatterns below.)</p>
            <p class="Body">Several assertions (of any sort) may occur in succession. For example,</p>
            <p class="Code-Indented">(?&lt;=\d{3})(?&lt;!999)foo</p>
            <p class="Body">matches "foo" preceded by three digits that are not "999". Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not "999". This pattern does not match "foo" preceded by six characters, the first of which are digits and the last three of which are not "999". For example, it does not match "123abcfoo". A pattern to do that is:</p>
            <p class="Code-Indented">(?&lt;=\d{3}...)(?&lt;!999)foo</p>
            <p class="Body">This time the first assertion looks at the preceding six characters, checking that the first three are digits, and then the second assertion checks that the preceding three characters are not "999". Assertions can be nested in any combination. For example,</p>
            <p class="Code-Indented">(?&lt;=(?&lt;!foo)bar)baz</p>
            <p class="Body">matches an occurrence of "baz" that is preceded by "bar" which in turn is not preceded by "foo", while</p>
            <p class="Code-Indented">(?&lt;=\d{3}(?!999)...)foo</p>
            <p class="Body">is another pattern which matches "foo" preceded by three digits and any three characters that are not "999".</p>
            <p class="Body">Assertion subpatterns are not capturing subpatterns, and may not be repeated, because it makes no sense to assert the same thing several times. If any kind of assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is carried out only for positive assertions, because it does not make sense for negative assertions.</p>
        </div>
        <div>
            <h4>Conditional Subpatterns</h4>
            <p class="Body">Conditional subpatterns allow you to apply "if-then" or "if-then-else" logic to pattern matching. The "if" portion can either be an integer between 1 and 99, or an assertion.</p>
            <p class="Body">The forms of syntax for an ordinary conditional subpattern are:</p>
            <p class="Code-Indented-No-Space"><em class="Number">if-then:</em> (?(condition)yes-pattern)</p>
            <p class="Code-Indented"><em class="Number">if-then-else:</em> (?(condition)yes-pattern|no-pattern)</p>
            <p class="Body">and for a named conditional subpattern are:</p>
            <p class="Code-Indented-No-Space"><em class="Number">if-then:</em> (?P&lt;NAME&gt;(condition)yes-pattern)</p>
            <p class="Code-Indented"><em class="Number">if-then-else:</em> (?P&lt;NAME&gt;(condition)yes-pattern|no-pattern)</p>
            <p class="Body">If the condition evaluates as true, the "yes-pattern" portion attempts to match. Otherwise, the "no-pattern" portion does (if there is a "no-pattern").</p>
            <p class="Body">If the "condition" text between the parentheses is an integer, it corresponds to the backreferenced subpattern with the same number. (Do not precede the number with a backslash.) If the corresponding backreference has previously matched in the pattern, the condition is satisfied. Here's an example of how this can be used. Let's say we want to match the words "red" or "blue", and refer to whichever word is matched in the replacement pattern. That's easy:</p>
            <p class="Code-Indented">(red|blue)</p>
            <p class="Body">To make it harder, let's say that if (and only if) we match "blue", we want to optionally match a space and the word "car" if they follow directly afterward. In other words, we want to match "red", "blue", or if possible, "blue car", but we do not want to match "red car". We cannot use the pattern:</p>
            <p class="Code-Indented">(red|blue)( car)?</p>
            <p class="Body">because that will match "red car". Nor can we use:</p>
            <p class="Code-Indented">(red|blue car|blue)</p>
            <p class="Body">because in our replacement pattern, we want the backreference to only contain "red" or "blue", without the " car". Using a conditional subpattern, however, we can search for:</p>
            <p class="Code-Indented">((blue)|(red))(?(2) car)?</p>
            <p class="Body">Here's how this pattern works. First, we start with "<em class="Code">((blue)|(red))</em> ". When this subpattern matches "blue", \1 and \2 are set to "blue", and \3 is empty. When it matches "red", \1 and \3 are set to "red", and \2 is empty.</p>
            <p class="Body">Next comes the conditional subpattern "<em class="Code">(?(2) car)?</em> ". The conditional test is on "2", the second backreferenced subpattern: if \2 is set, which in our case means it has matched the word "blue", then it will try to match " car". If \2 is not set, however, the entire conditional subpattern is skipped. The question mark at the end of the pattern makes this conditional match optional, even if \2 is set to "blue".</p>
            <p class="Body">Here's an example that uses an assertion for the condition, and the if-then-else form. Let's say we want to match a run of digits of any length, followed by either " is odd" or " is even", depending on whether the matched digits end with an odd or even digit.</p>
            <p class="Code-Indented">\d+(?(?&lt;=[13579]) is odd| is even)</p>
            <p class="Body">This pattern starts with "\d+" to match the digits. Next comes a conditional subpattern, with a positive lookbehind assertion as the condition to be satisfied. The lookbehind assertion is true only if the last character matched by <em class="Code">\d+</em> was also in the character class [13579]. If that is true, we next try to match " is odd"; if it is not, we try to match " is even". Thus, this pattern will match "123 is odd", "8 is even", and so on, but will not match "9 is even" or "144 is odd".</p>
        </div>
        <div>
            <h4>Once-Only Subpatterns</h4>
            <p class="Body">With both maximizing (greedy) and minimizing (non-greedy) repetition, failure of what follows normally causes the repeated item to be reevaluated to see if a different number of repeats allows the rest of the pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it to fail earlier than it otherwise might, when the author of the pattern knows there is no point in carrying on.</p>
            <p class="Body">Consider, for example, the pattern "<em class="Code">\d+foo</em> " when matching against the text "123456bar".</p>
            <p class="Body">After matching all 6 digits and then failing to match "foo", the normal action of the grep engine is to try again with only 5 digits matching the \d+ item, and then with 4, and so on, before ultimately failing. Once-only subpatterns provide the means for specifying that once a portion of the pattern has matched, it is not to be reevaluated in this way, so the matcher would give up immediately on failing to match "foo" the first time. The notation is another kind of special parenthesis, starting with "<em class="Code">(?&gt;</em> ", as in this example:</p>
            <p class="Code-Indented">(?&gt;\d+)bar</p>
            <p class="Body">This kind of parentheses "locks up" the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.</p>
            <p class="Body">In most situations, such as in the example above, the time saved by using once-only subpatterns is insignificant--a few small fractions of a second, at most. With some complicated grep patterns or with humongous lines of text, however, you can save tremendous amounts of time using once-only subpatterns.</p>
            <p class="Body">Once-only subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both <em class="Code">\d+</em> and <em class="Code">\d+?</em> are prepared to adjust the number of digits they match in order to make the rest of the pattern match, <em class="Code">(?&gt;\d+)</em> can only match an entire sequence of digits.</p>
            <p class="Body">Once-only subpatterns can be used in conjunction with lookbehind assertions to specify efficient matching at the end of a line of text. Consider a simple pattern such as:</p>
            <p class="Code-Indented">abcd$</p>
            <p class="Body">when applied to a long line of text which does not match (in other words, a long line of text that does not end with "abcd"). Because matching proceeds from left to right, the grep engine will look for each "a" in the subject and then see if what follows matches the rest of the pattern. If the pattern is specified as:</p>
            <p class="Code-Indented">^.*abcd$</p>
            <p class="Body">the initial <em class="Code">.*</em> matches the entire line at first, but when this fails (because there is no following "a"), it backtracks to match all but the last character, then all but the last two characters, and so on. Once again the search for "a" covers the entire string, from right to left, so we are no better off. However, if the pattern is written as:</p>
            <p class="Code-Indented">^(?&gt;.*)(?&lt;=abcd)</p>
            <p class="Body">there can be no backtracking for the <em class="Code">.*</em> item; it can match only the entire line. The subsequent lookbehind assertion does a single test on the last four characters. If it fails, the whole match fails immediately. For long strings, this approach makes a significant difference to the processing time.</p>
            <p class="Body">When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of a once-only subpattern is the only way to avoid some failing matches taking a very long time (literally millions or even billions of years, in some cases!). The pattern:</p>
            <p class="Code-Indented">(\D+|&lt;\d+&gt;)*[!?]</p>
            <p class="Body">matches an unlimited number of substrings that either consist of non-digits, or digits enclosed in &lt;&gt;, followed by either ! or ?. When it matches, it runs quickly. However, if it is attempts to match this line of text:</p>
            <p class="Code-Indented">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>
            <p class="Body">it takes a long time before reporting failure. So long, in fact, that it will effectively "freeze" TextWrangler. This is not really a crash, per se, but left to run on its own, it might take years before it finally fails. (We are not sure, frankly, because much like determining how many licks it takes to get to the center of a Tootsie Pop, we do not feel like waiting long enough to find out.)</p>
            <p class="Body">The reason this takes so long to fail is because the string can be divided between the two repeats in a large number of ways, and all have to be tried before the grep engine knows for certain that the pattern will not match. (The example used <em class="Code">[!?]</em> rather than a single character at the end, because both PCRE and Perl have an optimization that allows for fast failure when a single character is used. They remember the last single character that is required for a match, and fail early if it is not present in the string.) If the pattern is changed to</p>
            <p class="Code-Indented">((?&gt;\D+)|&lt;\d+&gt;)*[!?]</p>
            <p class="Body">sequences of non-digits cannot be broken, and failure happens quickly.</p>
        </div>
        <div>
            <h4>Recursive Patterns</h4>
            <p class="Body">Consider the problem of matching a string in parentheses, allowing for unlimited nested, balanced parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth. Perl 5.6 has provided an experimental facility that allows regular expressions to recurse (among other things). It does this by interpolating Perl code in the expression at run time, and the code can refer to the expression itself. Obviously, TextWrangler's grep engine cannot support the interpolation of Perl code. Instead, the special item <em class="Code">(?R)</em> is provided for the specific case of recursion. The following recursive pattern solves the parentheses problem:</p>
            <p class="Code-Indented">\(((?&gt;[^()]+)|(?R))*\)</p>
            <p class="Body">First it matches an opening parenthesis. Then it matches any number of substrings which can either be a sequence of non-parentheses, or a recursive match of the pattern itself (that is, a correctly parenthesized substring). Finally there is a closing parenthesis.</p>
            <p class="Body">This particular example pattern contains nested unlimited repeats, and so the use of a once-only subpattern for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when it tries to match against this line of text:</p>
            <p class="Code-Indented">(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</p>
            <p class="Body">it yields "no match" quickly. However, if a once-only subpattern is not used, the match runs for a very long time indeed because there are so many different ways the + and * repeats can carve up the subject, and all have to be tested before failure can be reported.</p>
        </div>
    </div>
    <div>
        <hr />

        <h3 id="Resources">Recommended Resources</h3>
        <div>
            <p class="Body">Our <a href="http://www.barebones.com/support/resources/bookshelf.html">company bookshelf</a> contains information about other books that you may find useful. We list one in particular here:</p>
            <h4>Mastering Regular Expressions, 3rd Edition</h4>
            <p class="Body">by Jeffrey E.F. Friedl. O'Reilly &amp; Associates, 2006. ISBN 0-596-52812-4</p>
            <p class="Body">Although it does not cover TextWrangler's grep features specifically, <i>Mastering Regular Expressions</i> is an outstanding resource for learning the "how-to" of writing useful grep patterns, and the latest edition is even better than the original.</p>
        </div>
        <div>
            <h4>TextWrangler Talk</h4>
            <p class="Body">The TextWrangler Talk discussion group covers a wide range of topics and questions about using TextWrangler, which frequently include searching and the use of grep patterns.</p>
            <p class="Code-Indented"><a href="http://groups.google.com/group/TextWrangler" class="URL" target="_blank">http://groups.google.com/group/TextWrangler</a></p>
        </div>
    </div>
</body>
</html>
